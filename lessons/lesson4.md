# 第4课 Python中的并发、异步与多线程

## 用途

考虑以下耗时操作：
* 从数据库或项目管理系统请求一个数据
* 从服务器读取或写入一个文件
* 大量的文件扫描或拷贝过程
* 渲染运算
* ……

这些操作都需要耗费一定的时间，并且依赖外部组件的性能，有时候甚至会中途进入持续等待的状态，
如果将这些操作全部写在顺序执行的函数中，那么在这些操作结束前，函数将无法继续执行或返回，
整个程序都将处于挂起等待的状态，对于用户而言，他们的直观感受就是"程序卡死了"。

更糟糕的是，在程序卡死的这段时间里，无法给用户任何的提示，无论是print还是弹出消息，
都需要在卡死状态结束后才能正常显示，所以在顺序执行的代码中，我们无法实现以下效果：

```python
print "即将执行耗时操作，请等待......" #这句话并不会在耗时操作结束前就被打印出来
do_something_with_long_time()
print "操作完成"
```
**这是一种非常糟糕的用户体验！**

如何解决：异步编程

另外，对于一个序列循环操作，我们希望能够同时执行其中的多项操作，而不是一项一项顺序执行，
这样可以成倍地节约时间，就好比一个工人搬100个箱子，和10个工人同时搬100个箱子，耗时肯定是不一样的。
这就是并发编程（以及并行编程）。

## 概念

参考文献：
* http://python.jobbole.com/88291/
* http://blog.51cto.com/itchentao/1895288

### 阻塞/非阻塞
第一节所举的例子中，函数等待耗时操作执行完毕才能继续往下运行，这时候就称该函数被耗时操作阻塞了，
程序无法继续运行或响应用户的任何操作，我们常见的程序卡死的状态（例如Maya和Nuke读取工程文件的时候）
就是典型的阻塞状态。

非阻塞只在存在**可独立运行**的子程序块时才能实现，简单来说就是单线程顺序执行的代码不能实现非阻塞。

### 同步/异步
同步包含两层意思：既指的是不同的代码单元依照既定的顺序执行，又指的是不同的代码单元以特定的通信形式保持协调一致。
在同步执行的代码中，我们可以预测任意时刻程序的状态，以及接下来会执行的操作。

异步指的是不同的代码单元各自按自己的时间周期独立执行，整个程序的运行顺序不定。

请注意区分几个概念，顺序执行的代码一定是同步的，因此无需通信机制来控制，而异步执行的代码如果需要保持协调一致，也会用到同步手段。
另外，同步/异步和阻塞/非阻塞也是两组独立的概念，通常情况下同步耗时操作是阻塞的，但也有同步非阻塞的情况，例如抛出非阻塞调用后用while循环或事件循环来等待结果，
同理，异步执行的代码通常是非阻塞的，但也会有阻塞的情况，例如线程池的`join()`操作。

在异步编程中，程序下一步行为往往依赖上一步执行结果，如何知晓上次异步调用已完成并获取结果？回调（Callback）成了必然选择。
那又需要面临“回调地狱”的折磨。同步代码改为异步代码，必然破坏代码结构。解决问题的逻辑也要转变，不再是一条路走到黑，
需要精心安排异步任务。

#### 回调函数
* https://learn.foundry.com/nuke/developers/11.2/pythondevguide/callbacks.html

**Callback的概念**

将某一函数A的指针（在Python中即为函数对象本身）作为参数传递给另一个函数B，以便在B函数中通过该参数调用A函数，则称A函数为回调函数。

**回调函数的优点**

* 解耦：由于回调函数是以参数的形式传入，所以可以按需配置，而无需像普通调用一样写死在处理函数中
* 异步：回调多用于异步编程，即将回调函数注册为处理函数的回调后就可以去做别的事情了，等到处理函数执行到特定时刻自然会去调用回调函数

**回调函数的缺点**
* 参数类型不定：由于传入的回调函数A是不定的，因此无法保证函数B能够在调用函数A时赋予其正确的参数
* 回调地狱：层级过深，运行顺序被打乱

**与信号-槽对比**
* 信号和槽的参数类型是严格对应的
* 信号和槽完全解偶，两者互不知道对方的存在
* 回调函数总是在处理函数所在的线程中执行，槽函数可以在调用方所在线程或其他线程中执行

**Nuke常用的Callback**
* OnCreate
* OnUserCreate
* OnScriptLoad
* OnScriptSave
* OnScriptClose
* beforeRender
* afterRender
* knobChanged

### 并发/并行
这组概念跟上述概念同样是独立的，并且是两个极易混淆的概念。并发指的是同一资源**一段时间内**可以执行多个任务，
而并行指的是**同一时刻**有多个任务在执行，我们通常说的"同时"其实指的是并行而不是并发。

### 进程/线程/协程

打开系统任务管理器，你所看到的就是进程，进程是可以在计算机系统中独立运行的程序，拥有独立的内存空间和状态。
进程的创建、执行和管理都需要耗费较多的系统资源。

线程是比进程更小、更轻量级的程序运行形态，线程包含在进程里，一个进程可以包含多个线程，并共享进程的内存空间和生命周期。
这也方便了同一进程下不同线程的通信与协调，是异步编程尤其是GUI编程中所使用的主要方案。

协程是比线程更小的程序单元，多个协程可以在同一个线程中运行，yield生成器就是最原始的协程运行形态。
需要注意的是，协程概念是在Python3.4中被引入的，在Python2中没有内置的协程支持库（第三方库有`gevent`）。

### GIL
GIL（全局解释器锁）是做Python并发编程所绕不开的一个问题，由于Python中的线程是直接交给操作系统管理的（即调用底层C++），
Python解释器自己没有管理权，因此为了确保多个线程之间的同步和安全，Python解释器同一时间内只允许一个线程执行，无论是在单核CPU上还是在多核CPU上。
需要注意的是，只有CPython解释器有GIL，其他的解释器如IronPython、PyPy是没有GIL的。GIL的保留更多是历史原因，
python官方曾经尝试过去掉GIL，但导致python性能至少缩减了一倍，而有没有人能够完全重写python，因此直到Python3，
GIL仍作为一个特性被保留。

由于GIL的存在，Python多线程并未实现真正的并行，而只有多进程才是真正的并行。

#### GIL与PySide/PyQt的关系
Python解释器在将程序控制权转交给C++模块时会释放GIL，因此Qt底层的C++是不受GIL限制的，事件循环、信号-槽机制也在这层上实现，
但是PySide/PyQt中的所有python代码都是受GIL限制的。

#### 自动切换
为了保证公平性，避免某一线程长期占用GIL，GIL会在执行一定的代码量之后自动切换到下一个线程，而这种切换时无法预测的，
也就是说，即便是有GIL确保了同一时间只有一个线程执行，在程序中仍然需要通过线程同步机制来控制多个线程的执行顺序和关系。

另外，执行IO操作的时候也会释放GIL，这也是为什么利用多线程可以显著提高IO操作性能的原因，而依赖CPU的计算密集型操作在
python多线程下就无法得到很好的加速。

### 总结
* 为了提高性能，可以使用并发和并行编程技术，实现方法包括多线程、多进程和协程
* 为了提高程序响应性、防止卡死，可以使用异步非阻塞编程
* 多线程、多进程经常与异步编程一起使用，通过同步机制控制各自的执行顺序和触发关系

## 多进程编程

`os.system()`/`os.popen()`:对于一次执行的无需返回值的系统命令可以使用这两个函数，而对于需要进行管理和通信的子进程，
官方建议使用更强大的`subprocess.Popen()`。

```python
import time

test_list = [i for i in range(10)]

def print_list():
	for i in test_list:
		print i
		time.sleep(1)

print_list()
```
用子进程来执行以上代码：
```python
import subprocess

s = subprocess.Popen(['python', '/Volumes/Seagate/tdclass/TDClass2_Nuke/cases/lesson5/print_ten.py'], stdout=subprocess.PIPE)

for line in iter(s.stdout.readline, ''):
	print line
```

`multiprocessing.Process`/`multiprocessing.Pool`

参考：https://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/0013868323401155ceb3db1e2044f80b974b469eb06cb43000

## 多线程编程

### map：常用于序列帧拷贝

```python
from multiprocessing.dummy import Pool

def single_process(one_thing):
    pass
    
p = Pool()
# map函数的两个参数分别为要执行的函数和一个列表，每执行一次map函数，就会从列表中拿一个值作为函数的参数进行运算
# map函数只能传入一个参数，如果函数需要用到多个参数，可以考虑元组、嵌套列表、lambda函数等技术
p.map(single_process, list_of_things)
# close()指的是关闭线程池，不再新建线程，且close()必须在join()之前调用
p.close()
# join()指的是主线程进入阻塞，等待所有map子线程运行完成后再往下运行
p.join()
```

需要特别注意的是，Pool线程池实例会自动创建子线程，因此这段代码只能在主线程或独立的子进程中使用，而不能在子线程中使用
（因为子线程中无法再创建线程池）。

### 直接创建Thread实例：常用于执行非阻塞操作

```python
from threading import Thread

def do_something(args):
    pass

t = Thread(target=do_something, args=())
t.start()
```

### 继承Thread类：可以实现更复杂的自定义函数

```python
from threading import Thread

class CustomThread(Thread):
    def __init__(self):
        super(CustomThread, self).__init__()
        
    def run(self):
        # do something
        pass
        
ct = CustomThread()
ct.start()
```

### 实例
子线程与子进程联用实现文件拷贝

## 通信、同步机制

在map实例中我们看到，join()函数用于阻塞主线程，防止子线程未运行完的情况下主线程提前退出，但是这样又会导致主线程无响应，
有没有更好的办法可以在不阻塞的情况下管理线程呢？这里就要用到同步机制。

在Thread实例中，子线程需要不断获取子进程输出的结果，这里就涉及到进程之间的通信，同理，子线程去更新GUI线程中的控件，
也是一种线程间通信。

在更多情况下，我们需要同步和通信机制来控制线程的运行顺序，例如某一线程要在另一线程结束后才能运行，并且要从另一线程拿数据，
例如某工具需要先收集数据，收集完后才能开始处理。

同步机制中需要特别注意的是锁机制，试想两个子线程都在运行，并且都会往同一个文件中写日志，如果不对两者的写入进行控制，
那么文件中记录日志一定是语句混乱的，这就好比开会的时候所有人同时发言一定听不清，必须依次发言才行。这时候就需要对多个线程所共享的资源加锁，
确保不同线程对其的操作不会产生冲突。比如抢火车票的情况，多个人一起抢，有人抢到了之后一定要锁定这张票，在取消订单前不能再被其他人抢走。

### 常用的同步和通信方式

* 信号：Qt中使用的同步机制
* 信号量：可以简单理解为全局变量，多个线程都可以访问到，共享内存（类变量）与之类似
* 管道：单向通信，Thread案例中就用到了子进程标准输出管道
* 队列：多个线程可以同时访问的一个动态存储区
  参考：https://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/0013868323401155ceb3db1e2044f80b974b469eb06cb43000
* 网络通信：用于分布式进程间通信，通过tcp/http协议进行消息传递

## Qt中的多线程

### Qt中的几种多线程实现方式
* QThread
* QTimer
* QRunnable + QThreadPool
* QObject.moveToThread

参考：https://blog.csdn.net/Spwper/article/details/80292004

### QThread与Thread对比
在PySide/PyQt中建议使用QThread来代替python原生的Thread，因为QThread可以使用诸多Qt专有的特性，
例如自定义信号的发射。

### 线程的分配和管理
请不要在子线程中直接控制和修改GUI线程，这样很容易造成程序崩溃，正确的做法是由子线程发出信号，
GUI线程将信号连接到对应的槽函数，执行槽函数来修改GUI。

子线程应当由主线程（即GUI实例）持有并作为其类变量，不要把子线程定义为函数局部变量，否则函数结束后子线程就会被销毁(
请注意子线程在start之后函数会继续往下运行)，同样容易造成程序崩溃。

### 实例
Nuke工程打包工具